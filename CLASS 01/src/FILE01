-- INTRODUCTION TO DSA

To store data (information), we need data structure, and structure varies based on requirements.
Example - Water (i.e, data / information)
For guest -> Glass
For bath -> Bucket
Here Glass and Bucket is structure.

To perform an operation / approach, we require Algorithm, more specifically - set of instruction to perform a specific task.
Example - Chai (Water, Tea, Sugar, Milk), all these are data
Water - bowl,
Tea, Sugar - container
Milk - bowl
Approach varies by person like one may add milk first and other person may add all ingredients at once.

Time complexity is the method to compare different approaches for a single program.



-- COLLECTIONS IN JAVA
A framework that provides various interface
List, Set, and Queue

Interface - Provide overview of class, we can't create object of Interface
class FILE01 implements OVERVIEW -> here OVERVIEW is an interface

LIST - When we want to store items one by one, repetition allowed
- ArrayList
- LinkedList
- Stack

SET - Elements are placed by hashing function, repetition not allowed, order of insertion not preserved
- HashSet
- LinkedHashSet
- TreeSet (Sorted)

QUEUE - FIFO (First in, first out)
- ArrayQueue
- LinkedList
- PriorityQueue (max. heap and min. head) - data is stored based on priority

MAP (Key - Value pair), key is unique but value can repeat
- HashMap
- TreeMap (Sorted)

* In List, Set, Queue - data are stored in value, various in Maps data are stored in Key - Value pair



-- EXTRA

LIST
ArrayList â†’ Backed by dynamic array
ğŸ“Œ Best when: frequent get, less frequent insert/delete
ğŸ§  Used in: Sliding Window, Two Pointers, Adjacency Lists (Graph)

LinkedList â†’ Doubly linked list
ğŸ“Œ Best when: frequent insert/delete at head/tail
ğŸ§  Used in: LRU Cache, Palindrome Linked List

Stack (extends Vector) â†’ LIFO
ğŸ“Œ Best when: reversal, backtracking
ğŸ§  Used in: Balanced Parentheses, DFS, Undo operation

SET
HashSet â†’ Backed by hash table
ğŸ“Œ Best for: O(1) lookup of unique elements
ğŸ§  Used in: Two Sum, Duplicate detection, Sliding Window (unique chars)

TreeSet â†’ Red-Black Tree (Self-Balancing BST)
ğŸ“Œ Best when: you need sorted access
ğŸ§  Used in: Range queries, Floor/Ceil problems

QUEUE
Queue (LinkedList / ArrayDeque) â†’ FIFO
ğŸ“Œ Best for: level-order traversal, scheduling
ğŸ§  Used in: BFS, Task Scheduling

PriorityQueue â†’ Min/Max Heap
ğŸ“Œ Best when: top K elements, greedy algorithms
ğŸ§  Used in: Dijkstraâ€™s, Median of Stream, Merge K Sorted Lists

MAP
HashMap â†’ Key-value with O(1) access
ğŸ“Œ Best for: frequency maps, look ups
ğŸ§  Used in: Two Sum, Anagrams, Caching

TreeMap â†’ Sorted key-value pairs
ğŸ“Œ Best when: ordered map needed
ğŸ§  Used in: Interval trees, Range queries



-- HASHING FUNCTION
A hashing function takes an input (like a string or number) and converts it into a fixed-size integer
called a hash code.

Used in:
HashSet â†’ to store unique values

HashMap â†’ to store and access key-value pairs

âš™ï¸ How it works:
Java calls the objectâ€™s .hashCode() method.
The hash code is used to decide which bucket (index) to place the data.
If two elements have the same hash code (collision), Java uses .equals() to resolve it.
Hashing allows for incredibly fast look ups, insertions, and deletions, typically in constant time, or O(1) on average.